## 代码加锁：不要让“锁”事成为烦心事
- 加锁前要清楚锁和被保护的对象是不是一个层面的：lockscope
- 加锁要考虑锁的粒度和场景问题：lockgranularity
- 多把锁要小心死锁问题：deadlock

## 重点回顾

1.在使用synchronized加锁时，首先要弄清楚共享资源是类还是实例级别的，会被哪些线程操作，synchronized关联的锁对象或者方法又是什么范围的
2.要考虑锁的粒度和使用场景，锁保护的代码，意味着无法进行多线程操作。
3.在业务逻辑中有多把锁时应该考虑死锁问题，通常的规避方案是，规避无限等待和循环等待。


如果业务逻辑中锁比较复杂的话，要仔细看看加锁和释放是否配对，是否有遗漏释放或者重复释放的可能性；
对于分布式锁，要考虑锁自动超时释放，而业务逻辑却还在进行的情况下，如果别的线程或者进项拿到了相同的锁，可能会导致重复执行。